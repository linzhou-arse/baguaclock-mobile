name: Build Android APK

on:
  workflow_dispatch:
    inputs:
      build_type:
        description: '构建类型'
        required: true
        default: 'debug'
        type: choice
        options:
          - debug
          - release

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            python3-pip \
            python3-dev \
            build-essential \
            git \
            unzip \
            openjdk-17-jdk \
            libffi-dev \
            libssl-dev \
            zlib1g-dev \
            libncurses5-dev \
            libbz2-dev \
            libreadline-dev \
            libsqlite3-dev \
            liblzma-dev \
            wget \
            curl \
            file \
            patchelf
      
      - name: Set up environment variables
        run: |
          # sdkmanager需要Java 17或更高版本
          # 强制设置Java 17，覆盖系统默认的Java 11
          echo "JAVA_HOME=/usr/lib/jvm/temurin-17-jdk-amd64" >> $GITHUB_ENV
          echo "PATH=/usr/lib/jvm/temurin-17-jdk-amd64/bin:$PATH" >> $GITHUB_ENV
          # 验证设置
          echo "✅ 环境变量已设置："
          echo "JAVA_HOME将在后续步骤中设置为: /usr/lib/jvm/temurin-17-jdk-amd64"
      
      - name: Install buildozer and dependencies
        run: |
          pip3 install --upgrade pip
          pip3 install --upgrade cython
          pip3 install buildozer
          pip3 install python-for-android
          echo "Buildozer安装完成"
      
      - name: Copy modules
        working-directory: mobile_app
        run: |
          python3 copy_modules.py || echo "模块复制可能有问题，继续构建"
      
      - name: Prepare build environment
        working-directory: mobile_app
        run: |
          # 检查buildozer.spec文件
          if [ ! -f buildozer.spec ]; then
            echo "❌ 错误：未找到buildozer.spec文件"
            exit 1
          fi
          
          # 检查图标文件
          if [ ! -f icon.png ]; then
            echo "⚠️  警告：未找到icon.png，创建默认图标..."
            # 创建一个简单的1x1像素PNG图标（base64编码的最小PNG）
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > icon.png || echo "图标创建失败，继续构建"
          fi
          
          # 检查main.py
          if [ ! -f main.py ]; then
            echo "❌ 错误：未找到main.py文件"
            exit 1
          fi
          
          # 显示目录结构
          echo "=== 当前目录结构 ==="
          ls -la
          echo "===================="
          
          # 显示buildozer配置
          echo "=== Buildozer配置 ==="
          cat buildozer.spec
          echo "===================="
      
      - name: Pre-download Android SDK and accept licenses
        run: |
          echo "=========================================="
          echo "预先下载Android SDK并接受许可"
          echo "=========================================="
          
          # 确保使用Java 17（sdkmanager需要Java 17，class file version 61.0）
          # Java 11的class file version是55.0，无法运行sdkmanager
          export JAVA_HOME="/usr/lib/jvm/temurin-17-jdk-amd64"
          export PATH="$JAVA_HOME/bin:$PATH"
          
          # 验证Java版本
          echo "验证Java版本..."
          java -version
          echo "JAVA_HOME: $JAVA_HOME"
          
          # 检查Java版本是否符合要求（必须是17或更高）
          JAVA_VERSION=$(java -version 2>&1 | head -n 1 | awk -F '"' '{print $2}' | cut -d'.' -f1)
          if [ "$JAVA_VERSION" -lt 17 ]; then
            echo "❌ 错误：Java版本 $JAVA_VERSION 过低，sdkmanager需要Java 17或更高版本"
            exit 1
          fi
          echo "✅ Java版本检查通过：$JAVA_VERSION"
          
          # 设置Android SDK目录（与buildozer使用相同的路径）
          ANDROID_SDK_ROOT="$HOME/.buildozer/android/platform/android-sdk"
          mkdir -p "$ANDROID_SDK_ROOT"
          
          # 设置环境变量
          export ANDROID_HOME="$ANDROID_SDK_ROOT"
          export ANDROID_SDK_ROOT="$ANDROID_SDK_ROOT"
          
          # 下载并安装Android SDK命令行工具
          if [ ! -f "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" ]; then
            echo "下载Android SDK命令行工具..."
            cd /tmp
            wget -q https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -O cmdline-tools.zip
            unzip -q cmdline-tools.zip
            
            # 创建正确的目录结构
            mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools/latest"
            
            # 移动解压的文件到正确位置
            if [ -d "cmdline-tools" ]; then
              # 如果解压后直接是cmdline-tools目录
              mv cmdline-tools/* "$ANDROID_SDK_ROOT/cmdline-tools/latest/" 2>/dev/null || true
              rmdir cmdline-tools 2>/dev/null || true
            else
              # 如果解压后是bin、lib等目录，直接移动
              mv bin lib NOTICE.txt source.properties "$ANDROID_SDK_ROOT/cmdline-tools/latest/" 2>/dev/null || true
            fi
            
            rm -f cmdline-tools.zip
            cd "$ANDROID_SDK_ROOT"
          fi
          
          # 设置PATH
          export PATH="$ANDROID_SDK_ROOT/cmdline-tools/latest/bin:$PATH"
          
          # 验证sdkmanager可用
          if [ ! -f "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" ]; then
            echo "⚠️  警告：sdkmanager未找到，跳过预安装"
            exit 0
          fi
          
          echo "✅ SDK Manager已准备就绪"
          
          # 接受所有许可（使用expect脚本）
          echo "接受Android SDK许可..."
          # 创建expect脚本，确保使用Java 17
          cat > /tmp/accept_licenses.exp << EXPECT
          #!/usr/bin/expect -f
          set timeout 300
          set env(JAVA_HOME) "$JAVA_HOME"
          set env(PATH) "$JAVA_HOME/bin:$env(PATH)"
          spawn "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --licenses
          expect {
              "Accept? (y/N):" {
                  send "y\r"
                  exp_continue
              }
              "y/N" {
                  send "y\r"
                  exp_continue
              }
              eof
          }
          EXPECT
          chmod +x /tmp/accept_licenses.exp
          
          # 安装expect如果还没有
          sudo apt-get install -y expect > /dev/null 2>&1 || true
          
          # 运行expect脚本接受许可（使用Java 17）
          JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" /tmp/accept_licenses.exp || {
            # 如果expect失败，使用简单方法
            echo "使用简单方法接受许可..."
            for i in {1..20}; do
              JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" echo "y" | "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --licenses > /dev/null 2>&1 && break
              sleep 1
            done
          }
          
          # 创建许可文件目录
          LICENSES_DIR="$ANDROID_SDK_ROOT/licenses"
          mkdir -p "$LICENSES_DIR"
          
          # 创建所有已知的许可文件（这是最可靠的方法）
          echo "创建Android SDK许可文件..."
          LICENSE_HASH="24333f8a63b6825ea9c5514f83c2829b004d1fee"
          
          # 所有可能的许可文件名
          for license in \
            "android-sdk-preview-license" \
            "android-sdk-license" \
            "android-googletv-license" \
            "android-sdk-arm-dbt-license" \
            "google-gdk-license" \
            "intel-android-extra-license" \
            "mips-android-sysimage-license" \
            "android-sdk-arm-dbt-license"; do
            echo "$LICENSE_HASH" > "$LICENSES_DIR/$license"
          done
          
          echo "✅ 已创建 $(ls -1 "$LICENSES_DIR" | wc -l) 个许可文件"
          
          # 使用expect脚本接受许可（更可靠）
          echo "使用expect脚本接受许可..."
          cat > /tmp/accept_all_licenses.exp << EXPECT_SCRIPT
          #!/usr/bin/expect -f
          set timeout 60
          set env(JAVA_HOME) "$JAVA_HOME"
          set env(PATH) "$JAVA_HOME/bin:$env(PATH)"
          spawn "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --licenses
          expect {
              "Accept? (y/N):" {
                  send "y\r"
                  exp_continue
              }
              "y/N" {
                  send "y\r"
                  exp_continue
              }
              "All SDK package licenses accepted" {
                  send_user "✅ 所有许可已接受\n"
                  exp_continue
              }
              eof
          }
          EXPECT_SCRIPT
          chmod +x /tmp/accept_all_licenses.exp
          
          # 运行expect脚本（使用Java 17）
          JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" /tmp/accept_all_licenses.exp || {
            echo "⚠️  expect脚本失败，使用备用方法..."
            # 备用方法：多次尝试（使用Java 17）
            for i in {1..30}; do
              JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" echo "y" | "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --licenses 2>&1 | grep -q "All SDK package licenses accepted" && break
              sleep 1
            done
          }
          
          # 验证许可文件
          if [ -f "$LICENSES_DIR/android-sdk-license" ]; then
            echo "✅ 许可文件已创建"
            cat "$LICENSES_DIR/android-sdk-license"
          fi
          
          # 预先安装所需的build-tools（使用非交互模式）
          echo "预先安装Android SDK Build-Tools 36.1.0..."
          
          # 设置ANDROID_SDK_ROOT环境变量
          export ANDROID_SDK_ROOT="$ANDROID_SDK_ROOT"
          export ANDROID_HOME="$ANDROID_SDK_ROOT"
          
          # 安装build-tools（使用环境变量确保许可被识别）
          # 确保使用Java 17执行sdkmanager
          # 注意：NDK版本改为25b（与buildozer.spec中的配置匹配）
          echo "使用Java 17执行sdkmanager安装组件..."
          JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" yes | "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" \
            --sdk_root="$ANDROID_SDK_ROOT" \
            "build-tools;36.1.0" \
            "platforms;android-31" \
            "platforms;android-21" \
            "platform-tools" \
            "ndk;25.1.8937393" \
            2>&1 | tee /tmp/sdk_install.log || {
            echo "⚠️  安装可能失败，查看日志..."
            tail -n 20 /tmp/sdk_install.log
            echo "检查Java版本..."
            java -version
            echo "JAVA_HOME: $JAVA_HOME"
          }
          
          # 验证安装
          if [ -d "$ANDROID_SDK_ROOT/build-tools/36.1.0" ]; then
            echo "✅ Android SDK Build-Tools 36.1.0 已安装"
            ls -la "$ANDROID_SDK_ROOT/build-tools/36.1.0/bin/" | head -n 10
          else
            echo "⚠️  警告：Build-Tools目录未找到"
            echo "SDK目录内容："
            ls -la "$ANDROID_SDK_ROOT/" || true
          fi
          
          # 确保许可文件对buildozer可见
          echo "许可文件位置：$LICENSES_DIR"
          ls -la "$LICENSES_DIR" || true
          
          # 创建兼容性链接：buildozer期望sdkmanager在tools/bin，但新版本在cmdline-tools/latest/bin
          echo "创建SDK工具兼容性链接..."
          mkdir -p "$ANDROID_SDK_ROOT/tools/bin"
          mkdir -p "$ANDROID_SDK_ROOT/tools/lib"
          
          # 检查cmdline-tools是否存在
          if [ ! -f "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" ]; then
            echo "❌ 错误：cmdline-tools未找到"
            echo "SDK目录结构："
            ls -la "$ANDROID_SDK_ROOT/" || true
            exit 1
          fi
          
          # 创建包装脚本而不是符号链接（更可靠）
          # sdkmanager需要Java 17或更高版本
          cat > "$ANDROID_SDK_ROOT/tools/bin/sdkmanager" << 'SDKWRAPPER'
          #!/bin/bash
          # Wrapper script for sdkmanager
          # sdkmanager需要Java 17或更高版本（class file version 61.0）
          # 强制使用Java 17，覆盖任何系统默认值
          export JAVA_HOME="/usr/lib/jvm/temurin-17-jdk-amd64"
          export PATH="$JAVA_HOME/bin:$PATH"
          SDK_ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
          exec "$SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" "$@"
          SDKWRAPPER
          
          chmod +x "$ANDROID_SDK_ROOT/tools/bin/sdkmanager"
          echo "✅ sdkmanager包装脚本已创建"
          
          # 复制lib目录（sdkmanager需要依赖库）
          if [ -d "$ANDROID_SDK_ROOT/cmdline-tools/latest/lib" ]; then
            cp -r "$ANDROID_SDK_ROOT/cmdline-tools/latest/lib"/* "$ANDROID_SDK_ROOT/tools/lib/" 2>/dev/null || true
            echo "✅ lib目录已复制"
          fi
          
          # 验证sdkmanager是否能正常运行
          echo "测试sdkmanager..."
          # 确保使用Java 17
          export JAVA_HOME="${JAVA_HOME:-/usr/lib/jvm/temurin-17-jdk-amd64}"
          export PATH="$JAVA_HOME/bin:$PATH"
          
          # 先测试cmdline-tools版本（直接调用）
          echo "测试cmdline-tools版本的sdkmanager..."
          if JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --version > /dev/null 2>&1; then
            echo "✅ cmdline-tools版本的sdkmanager测试成功"
            JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --version | head -n 3
          else
            echo "⚠️  cmdline-tools版本的sdkmanager测试失败"
            echo "错误信息："
            JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" "$ANDROID_SDK_ROOT/cmdline-tools/latest/bin/sdkmanager" --version 2>&1 || true
          fi
          
          # 测试包装脚本版本
          if JAVA_HOME="$JAVA_HOME" PATH="$JAVA_HOME/bin:$PATH" "$ANDROID_SDK_ROOT/tools/bin/sdkmanager" --version > /dev/null 2>&1; then
            echo "✅ 包装脚本版本的sdkmanager测试成功"
          else
            echo "⚠️  包装脚本版本的sdkmanager测试失败，但继续构建"
          fi
          
          # 确保tools/bin目录在PATH中
          export PATH="$ANDROID_SDK_ROOT/tools/bin:$PATH"
          
          echo "✅ Android SDK组件安装完成"
      
      - name: Build APK
        working-directory: mobile_app
        env:
          JAVA_HOME: /usr/lib/jvm/temurin-17-jdk-amd64
        run: |
          echo "=========================================="
          echo "开始构建APK..."
          echo "构建类型: ${{ github.event.inputs.build_type }}"
          echo "=========================================="
          
          # 强制设置环境变量指向buildozer的SDK目录
          export ANDROID_HOME="$HOME/.buildozer/android/platform/android-sdk"
          export ANDROID_SDK_ROOT="$HOME/.buildozer/android/platform/android-sdk"
          
          # 强制使用Java 17（sdkmanager需要，class file version 61.0）
          # 覆盖任何之前设置的JAVA_HOME（可能是Java 11）
          export JAVA_HOME="/usr/lib/jvm/temurin-17-jdk-amd64"
          export PATH="$JAVA_HOME/bin:$PATH"
          
          # 验证Java版本
          echo "验证Java环境..."
          java -version
          echo "JAVA_HOME: $JAVA_HOME"
          JAVA_VERSION=$(java -version 2>&1 | head -n 1 | awk -F '"' '{print $2}' | cut -d'.' -f1)
          if [ "$JAVA_VERSION" -lt 17 ]; then
            echo "❌ 错误：Java版本 $JAVA_VERSION 过低，需要Java 17或更高版本"
            exit 1
          fi
          echo "✅ Java版本检查通过：$JAVA_VERSION"
          
          # 验证SDK和许可文件存在
          echo "验证Android SDK环境..."
          echo "ANDROID_HOME: $ANDROID_HOME"
          echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"
          
          if [ -d "$ANDROID_HOME" ]; then
            echo "✅ SDK目录存在"
            echo "SDK目录内容："
            ls -la "$ANDROID_HOME/" | head -n 10
            
            if [ -d "$ANDROID_HOME/licenses" ]; then
              echo "✅ 许可目录存在"
              echo "许可文件："
              ls -la "$ANDROID_HOME/licenses/" || true
            else
              echo "⚠️  许可目录不存在，创建..."
              mkdir -p "$ANDROID_HOME/licenses"
              echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" > "$ANDROID_HOME/licenses/android-sdk-license"
            fi
            
            if [ -d "$ANDROID_HOME/build-tools/36.1.0" ]; then
              echo "✅ Build-Tools 36.1.0 已安装"
              if [ -f "$ANDROID_HOME/build-tools/36.1.0/bin/aidl" ]; then
                echo "✅ aidl工具已找到"
              else
                echo "⚠️  aidl工具未找到"
              fi
            else
              echo "⚠️  Build-Tools 36.1.0 未找到"
            fi
          else
            echo "⚠️  SDK目录不存在，buildozer将创建它"
          fi
          
          # 创建wrapper脚本来处理许可接受和Java环境
          cat > build_with_licenses.sh << SCRIPT
          #!/bin/bash
          # Wrapper脚本：自动接受Android SDK许可并构建
          # 确保使用Java 17
          
          # 强制设置Java 17环境
          export JAVA_HOME="/usr/lib/jvm/temurin-17-jdk-amd64"
          export PATH="\$JAVA_HOME/bin:\$PATH"
          
          # 函数：接受许可
          accept_licenses() {
            local sdk_path="\$HOME/.buildozer/android/platform/android-sdk"
            if [ -f "\$sdk_path/cmdline-tools/latest/bin/sdkmanager" ]; then
              echo "接受Android SDK许可..."
              JAVA_HOME="\$JAVA_HOME" PATH="\$JAVA_HOME/bin:\$PATH" yes | "\$sdk_path/cmdline-tools/latest/bin/sdkmanager" --licenses > /dev/null 2>&1 || true
            fi
          }
          
          # 首次尝试接受许可
          accept_licenses
          
          # 运行构建命令（确保使用Java 17）
          if [ "\$1" = "release" ]; then
            JAVA_HOME="\$JAVA_HOME" PATH="\$JAVA_HOME/bin:\$PATH" buildozer android release 2>&1 | tee build.log
          else
            JAVA_HOME="\$JAVA_HOME" PATH="\$JAVA_HOME/bin:\$PATH" buildozer android debug 2>&1 | tee build.log
          fi
          
          BUILD_EXIT_CODE=\${PIPESTATUS[0]}
          
          # 如果构建失败且日志显示许可问题，再次接受许可并重试
          if [ \$BUILD_EXIT_CODE -ne 0 ] && grep -q "license.*not accepted\|Accept? (y/N)" build.log 2>/dev/null; then
            echo "检测到许可问题，重新接受许可并重试..."
            accept_licenses
            sleep 2
            
            if [ "\$1" = "release" ]; then
              JAVA_HOME="\$JAVA_HOME" PATH="\$JAVA_HOME/bin:\$PATH" buildozer android release 2>&1 | tee -a build.log
            else
              JAVA_HOME="\$JAVA_HOME" PATH="\$JAVA_HOME/bin:\$PATH" buildozer android debug 2>&1 | tee -a build.log
            fi
            BUILD_EXIT_CODE=\${PIPESTATUS[0]}
          fi
          
          exit \$BUILD_EXIT_CODE
          SCRIPT
          
          chmod +x build_with_licenses.sh
          
          # 设置构建超时（30分钟）
          # buildozer会自动下载所需的Android SDK和NDK
          # 首次构建可能需要较长时间（10-30分钟）
          set +e  # 不立即退出，先捕获错误
          
          # 确保wrapper脚本可执行
          chmod +x build_with_licenses.sh
          
          # 设置构建环境变量
          # 注意：buildozer会自动下载NDK，但我们需要确保路径正确
          # 先检查实际安装的NDK版本
          echo "检查NDK安装情况..."
          if [ -d "$HOME/.buildozer/android/platform" ]; then
            echo "NDK目录内容："
            ls -la "$HOME/.buildozer/android/platform/" || echo "无法列出目录"
            echo ""
            # 查找实际的NDK目录
            NDK_DIR=$(find "$HOME/.buildozer/android/platform" -maxdepth 1 -type d -name "*ndk*" 2>/dev/null | head -n 1)
            if [ -n "$NDK_DIR" ]; then
              echo "找到NDK目录: $NDK_DIR"
              export ANDROIDNDK="$NDK_DIR"
            else
              echo "未找到NDK目录，buildozer将自动下载"
              export ANDROIDNDK="$HOME/.buildozer/android/platform/android-ndk-r25b"
            fi
          else
            export ANDROIDNDK="$HOME/.buildozer/android/platform/android-ndk-r25b"
          fi
          
          export ANDROIDSDK="$HOME/.buildozer/android/platform/android-sdk"
          export ANDROIDAPI=31
          export ANDROIDMINAPI=21
          
          echo "环境变量设置："
          echo "  ANDROIDNDK=$ANDROIDNDK"
          echo "  ANDROIDSDK=$ANDROIDSDK"
          echo "  ANDROIDAPI=$ANDROIDAPI"
          echo "  ANDROIDMINAPI=$ANDROIDMINAPI"
          
          # 使用wrapper脚本构建（wrapper脚本会确保使用Java 17）
          echo "使用wrapper脚本构建，确保Java 17环境..."
          echo "ANDROIDNDK: $ANDROIDNDK"
          echo "ANDROIDSDK: $ANDROIDSDK"
          
          # 直接运行buildozer，捕获详细错误
          # 使用临时文件来捕获退出代码
          # 先清理之前的构建（避免缓存问题）
          echo "清理之前的构建缓存..."
          rm -rf .buildozer/android/platform/build-* 2>/dev/null || true
          
          # 设置更详细的日志级别
          export BUILDOZER_LOG_LEVEL=2
          
          echo "开始构建..."
          if [ "${{ github.event.inputs.build_type }}" = "release" ]; then
            buildozer -v android release 2>&1 | tee build.log
            BUILD_EXIT_CODE=${PIPESTATUS[0]}
          else
            buildozer -v android debug 2>&1 | tee build.log
            BUILD_EXIT_CODE=${PIPESTATUS[0]}
          fi
          
          echo ""
          echo "构建命令退出代码: $BUILD_EXIT_CODE"
          
          set -e  # 恢复错误退出
          
          # 检查构建是否真正成功：验证APK文件是否存在
          echo ""
          echo "=========================================="
          echo "验证构建结果..."
          echo "=========================================="
          
          APK_FOUND=0
          if [ -d "bin" ]; then
            echo "bin目录存在，检查APK文件..."
            APK_FILES=$(find bin -name "*.apk" -o -name "*.aab" 2>/dev/null)
            if [ -n "$APK_FILES" ]; then
              echo "✅ 找到APK/AAB文件："
              echo "$APK_FILES"
              APK_FOUND=1
            else
              echo "⚠️  bin目录存在但没有APK/AAB文件"
              ls -la bin/ || echo "无法列出bin目录内容"
            fi
          else
            echo "⚠️  bin目录不存在"
            # 检查.buildozer目录中是否有APK
            DIST_APK=$(find .buildozer -name "*.apk" -o -name "*.aab" 2>/dev/null | head -n 1)
            if [ -n "$DIST_APK" ]; then
              echo "⚠️  在.buildozer目录找到APK，但未复制到bin目录："
              echo "$DIST_APK"
            fi
          fi
          
          # 如果APK不存在，即使退出代码为0也视为失败
          if [ $APK_FOUND -eq 0 ]; then
            echo ""
            echo "❌ 构建失败：未找到APK文件"
            BUILD_EXIT_CODE=1
          fi
          
          # 如果构建失败，检查是否是Java版本问题
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "=========================================="
            echo "构建失败，检查环境..."
            echo "=========================================="
            echo "当前JAVA_HOME: ${JAVA_HOME:-未设置}"
            java -version 2>&1 | head -n 3 || echo "无法执行java命令"
            echo ""
            echo "检查NDK..."
            if [ -d "$ANDROIDNDK" ]; then
              echo "✅ NDK目录存在: $ANDROIDNDK"
              ls -la "$ANDROIDNDK" | head -n 5
            else
              echo "⚠️  NDK目录不存在: $ANDROIDNDK"
            fi
            echo ""
            echo "检查SDK..."
            if [ -d "$ANDROIDSDK" ]; then
              echo "✅ SDK目录存在: $ANDROIDSDK"
              ls -la "$ANDROIDSDK" | head -n 10
            else
              echo "⚠️  SDK目录不存在: $ANDROIDSDK"
            fi
          fi
          
          # 显示构建日志的最后200行（增加行数以查看更多错误信息）
          echo "=========================================="
          echo "构建日志（最后200行）:"
          echo "=========================================="
          tail -n 200 build.log || echo "无法读取构建日志"
          
          # 查找pythonforandroid相关的错误
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "=========================================="
            echo "查找pythonforandroid错误..."
            echo "=========================================="
            grep -i "pythonforandroid\|toolchain\|error\|exception\|traceback\|failed\|Failed\|FAILED" build.log | tail -n 100 || echo "未找到相关错误"
            
            echo ""
            echo "=========================================="
            echo "查找关键错误信息..."
            echo "=========================================="
            # 查找toolchain create命令的详细输出
            grep -A 20 "pythonforandroid.toolchain create" build.log | tail -n 30 || echo "未找到toolchain create输出"
            
            echo ""
            echo "=========================================="
            echo "检查NDK和SDK..."
            echo "=========================================="
            if [ -d "$ANDROIDNDK" ]; then
              echo "✅ NDK目录存在: $ANDROIDNDK"
              ls -la "$ANDROIDNDK" | head -n 10
            else
              echo "❌ NDK目录不存在: $ANDROIDNDK"
              echo "尝试查找其他NDK位置..."
              find "$HOME/.buildozer" -type d -name "*ndk*" 2>/dev/null | head -n 5 || echo "未找到NDK"
            fi
            
            if [ -d "$ANDROIDSDK" ]; then
              echo "✅ SDK目录存在: $ANDROIDSDK"
            else
              echo "❌ SDK目录不存在: $ANDROIDSDK"
            fi
          fi
          
          # 如果构建失败，显示错误信息
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "=========================================="
            echo "❌ 构建失败！退出代码: $BUILD_EXIT_CODE"
            echo "=========================================="
            echo ""
            echo "常见错误及解决方案："
            echo "1. 模块找不到：确保已运行copy_modules.py"
            echo "2. 依赖下载失败：检查网络连接"
            echo "3. Android SDK问题：buildozer会自动下载，请等待"
            echo "4. 内存不足：GitHub Actions限制，可能需要简化构建"
            echo ""
            echo "完整构建日志："
            cat build.log || echo "无法读取完整日志"
            exit $BUILD_EXIT_CODE
          fi
          
          # 再次确认APK文件存在
          if [ $APK_FOUND -eq 1 ]; then
            echo ""
            echo "=========================================="
            echo "✅ 构建完成！APK文件已生成"
            echo "=========================================="
            echo "APK文件位置："
            find bin -name "*.apk" -o -name "*.aab" 2>/dev/null | while read apk; do
              echo "  - $apk ($(du -h "$apk" | cut -f1))"
            done
          else
            echo ""
            echo "=========================================="
            echo "❌ 构建失败：未生成APK文件"
            echo "=========================================="
            exit 1
          fi
      
      - name: Upload build log file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-log-full
          path: mobile_app/build.log
          if-no-files-found: warn
          retention-days: 7
      
      - name: Check build results
        working-directory: mobile_app
        run: |
          echo "=== 检查构建结果 ==="
          echo ""
          
          # 检查bin目录
          if [ -d "bin" ]; then
            echo "✅ bin目录存在"
            echo "bin目录内容:"
            ls -la bin/ || echo "无法列出bin目录"
            
            # 查找APK文件
            APK_COUNT=$(find bin -name "*.apk" -o -name "*.aab" 2>/dev/null | wc -l)
            if [ "$APK_COUNT" -gt 0 ]; then
              echo ""
              echo "✅ 找到 $APK_COUNT 个APK/AAB文件："
              find bin -name "*.apk" -o -name "*.aab" 2>/dev/null | while read apk; do
                echo "  - $apk ($(du -h "$apk" 2>/dev/null | cut -f1 || echo '未知大小'))"
              done
            else
              echo ""
              echo "⚠️  警告：bin目录中没有APK/AAB文件"
            fi
          else
            echo "❌ 未找到bin目录"
          fi
          
          echo ""
          echo "检查.buildozer目录..."
          if [ -d ".buildozer" ]; then
            echo ".buildozer目录结构:"
            find .buildozer -type d -maxdepth 2 2>/dev/null | head -n 20 || echo "无法列出.buildozer目录"
            
            # 检查是否有APK在.buildozer中
            DIST_APK=$(find .buildozer -name "*.apk" -o -name "*.aab" 2>/dev/null | head -n 5)
            if [ -n "$DIST_APK" ]; then
              echo ""
              echo "⚠️  在.buildozer目录找到APK文件（但未在bin目录）："
              echo "$DIST_APK"
            fi
          fi
          
          echo ""
          echo "=================="
      
      - name: Find and copy APK files
        working-directory: mobile_app
        run: |
          echo "=== 查找APK文件 ==="
          # 确保bin目录存在
          mkdir -p bin
          
          # 从.buildozer目录复制APK到bin目录（如果存在）
          if [ -d ".buildozer" ]; then
            echo "在.buildozer目录中查找APK文件..."
            find .buildozer -name "*.apk" -o -name "*.aab" 2>/dev/null | while read apk; do
              echo "找到APK: $apk"
              cp "$apk" bin/ 2>/dev/null && echo "已复制到bin目录: $(basename "$apk")" || echo "复制失败: $apk"
            done
          fi
          
          # 显示最终结果
          echo ""
          echo "bin目录中的APK文件："
          ls -lah bin/*.apk bin/*.aab 2>/dev/null || echo "未找到APK文件"
      
      - name: Upload APK
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: apk-file-${{ github.event.inputs.build_type }}
          path: |
            mobile_app/bin/*.apk
            mobile_app/bin/*.aab
            mobile_app/.buildozer/**/*.apk
            mobile_app/.buildozer/**/*.aab
          if-no-files-found: warn
          retention-days: 30
      
      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            mobile_app/.buildozer/**/*.log
            mobile_app/.buildozer/android/platform/build-*/dists/*/build.log
          if-no-files-found: warn
          retention-days: 7

